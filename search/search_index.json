{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"another self-built home automation system My main focus was a robust, self-sufficient control system with which I could not depend on a proprietary system from a single manufacturer but could expand with hardware / software from different manufacturers. Here my choice fell on Simatic CPUs. The sensors and actuators are wired to these and they process the control program. Via the LAN interface, the CPUs communicate with a NAS running a data logger script. Here various data are stored in a mySQL database for later evaluation. As a central control system I use NodeRed which provides a webserver for operation (and a lot of help during development). Requirements type desc robustnes When switching on (e.g. after a power failure) the system itself should start up and be active robustnes Services / applications on servers should be monitored automatically and restarted if necessary robustnes Backups of databases and other artifacts should be created automatically. interoperability The different components of the system shall provide apis to exchange information and communicate with internal and external applications and systems. interoperability The system shall be open to different transport protocols and publishing / describing interfaces. interoperability For integrating iot devices the system provides shall provide a MQTT broker. That allows easy w-lan connecting of esp based devices interoperability The PLC shall communicate to sensors / actors hardwired, via modbus, analog voltage signals, ... interoperability The data formats, transport protocols and interfaces shall be derived from central managed masterdata Components source here another view of the main components Warning of course I am not liable for any damage caused by replicas ;-)","title":"Home"},{"location":"#another-self-built-home-automation-system","text":"My main focus was a robust, self-sufficient control system with which I could not depend on a proprietary system from a single manufacturer but could expand with hardware / software from different manufacturers. Here my choice fell on Simatic CPUs. The sensors and actuators are wired to these and they process the control program. Via the LAN interface, the CPUs communicate with a NAS running a data logger script. Here various data are stored in a mySQL database for later evaluation. As a central control system I use NodeRed which provides a webserver for operation (and a lot of help during development).","title":"another self-built home automation system"},{"location":"#requirements","text":"type desc robustnes When switching on (e.g. after a power failure) the system itself should start up and be active robustnes Services / applications on servers should be monitored automatically and restarted if necessary robustnes Backups of databases and other artifacts should be created automatically. interoperability The different components of the system shall provide apis to exchange information and communicate with internal and external applications and systems. interoperability The system shall be open to different transport protocols and publishing / describing interfaces. interoperability For integrating iot devices the system provides shall provide a MQTT broker. That allows easy w-lan connecting of esp based devices interoperability The PLC shall communicate to sensors / actors hardwired, via modbus, analog voltage signals, ... interoperability The data formats, transport protocols and interfaces shall be derived from central managed masterdata","title":"Requirements"},{"location":"#components","text":"source here another view of the main components Warning of course I am not liable for any damage caused by replicas ;-)","title":"Components"},{"location":"control_system/","text":"Control system Node red As control system and for the connection of other devices I currently use node-RED . Node-RED is a programming tool for wiring together hardware devices, APIs and online services It has already implemented interfaces (which are called 'nodes') to a lot of devices I use. Requirements regarding plugins node-red-dashboard node-red-contrib-fritz node-red-contrib-s7 node-red-node-mysql node-red-contrib-os node-red-contrib-mqtt-broker node-red-node-email (outdated) node-red-contrib-netatmo node-red-contrib-netatmo-dashboard node-red-contrib-viera Dashboards It is easy to make quick dash boards to monitor the sensor and health state of the devices. Or to configure debug / control clients for different devices Grafana Using an open source solution is much easier than implementing a monitor dashboard yourself. Grafana is the open source analytics and monitoring solution for every database I had good experiences with grafana . Out of the box even larger time ranges are displayed performant. I can recommend this installation pages mqtt mosquitto Eclipse Mosquitto is an open source message broker that implements the MQTT protocol Raspberry setup Most of the control components are running as docker image on a raspberry. Here are a few steps to set up: enable ssh server copy the puplic key to the raspberry for easier access cat ~/.ssh/id_rsa.pub | ssh pi_name@192.168.xxx.xxx -p 22 'mkdir -p ~/.ssh cat ~/.ssh/authorized_keys' get docker `sudo apt-get update sudo apt-get upgrade -y` `curl -sSL https://get.docker.com | sh` `sudo usermod -aG docker $USER` setup container mqtt mosquitto docker run -itd -p 1883:1883 -p 9001:9001 --name mosquitto_ah eclipse-mosquitto setup container node red Mind that as long as we run the mosquitto and node-red container at the same host the --link mosquitto_ah:broker is necessary. If changing the deployment to different machines update the node-red-mqtt-server from broker to the new ip address sudo chown -R 1000:1000 /home/pi/.node-red docker run -it -p 1880:1880 -p 7724:7724/udp -p 7725:7725/udp -v /home/pi/.node-red:/data --restart=always --name nodered_ah --link mosquitto_ah:broker nodered/node-red setup container grafana docker volume create grafana-storage docker run -d -p 3000:3000 -v grafana-storage:/var/lib/grafana --name=grafana_ah grafana/grafana setup pi hole The network ad blocking / monitoring software pi-hole.net is not really connected to the home automation system but it is always a good idear to have control over your network. dotNet tool Here are some historical pics of the outdated dot net tool.","title":"control"},{"location":"control_system/#control-system","text":"","title":"Control system"},{"location":"control_system/#node-red","text":"As control system and for the connection of other devices I currently use node-RED . Node-RED is a programming tool for wiring together hardware devices, APIs and online services It has already implemented interfaces (which are called 'nodes') to a lot of devices I use.","title":"Node red"},{"location":"control_system/#requirements-regarding-plugins","text":"node-red-dashboard node-red-contrib-fritz node-red-contrib-s7 node-red-node-mysql node-red-contrib-os node-red-contrib-mqtt-broker node-red-node-email (outdated) node-red-contrib-netatmo node-red-contrib-netatmo-dashboard node-red-contrib-viera","title":"Requirements regarding plugins"},{"location":"control_system/#dashboards","text":"It is easy to make quick dash boards to monitor the sensor and health state of the devices. Or to configure debug / control clients for different devices","title":"Dashboards"},{"location":"control_system/#grafana","text":"Using an open source solution is much easier than implementing a monitor dashboard yourself. Grafana is the open source analytics and monitoring solution for every database I had good experiences with grafana . Out of the box even larger time ranges are displayed performant. I can recommend this installation pages","title":"Grafana"},{"location":"control_system/#mqtt-mosquitto","text":"Eclipse Mosquitto is an open source message broker that implements the MQTT protocol","title":"mqtt mosquitto"},{"location":"control_system/#raspberry-setup","text":"Most of the control components are running as docker image on a raspberry. Here are a few steps to set up: enable ssh server copy the puplic key to the raspberry for easier access cat ~/.ssh/id_rsa.pub | ssh pi_name@192.168.xxx.xxx -p 22 'mkdir -p ~/.ssh cat ~/.ssh/authorized_keys' get docker `sudo apt-get update sudo apt-get upgrade -y` `curl -sSL https://get.docker.com | sh` `sudo usermod -aG docker $USER` setup container mqtt mosquitto docker run -itd -p 1883:1883 -p 9001:9001 --name mosquitto_ah eclipse-mosquitto setup container node red Mind that as long as we run the mosquitto and node-red container at the same host the --link mosquitto_ah:broker is necessary. If changing the deployment to different machines update the node-red-mqtt-server from broker to the new ip address sudo chown -R 1000:1000 /home/pi/.node-red docker run -it -p 1880:1880 -p 7724:7724/udp -p 7725:7725/udp -v /home/pi/.node-red:/data --restart=always --name nodered_ah --link mosquitto_ah:broker nodered/node-red setup container grafana docker volume create grafana-storage docker run -d -p 3000:3000 -v grafana-storage:/var/lib/grafana --name=grafana_ah grafana/grafana setup pi hole The network ad blocking / monitoring software pi-hole.net is not really connected to the home automation system but it is always a good idear to have control over your network.","title":"Raspberry setup"},{"location":"control_system/#dotnet-tool","text":"Here are some historical pics of the outdated dot net tool.","title":"dotNet tool"},{"location":"field_level/","text":"Field level IoT multisensor TODO esp 8266 description requirements upload stl file Data logger During the early implementing phase of the home automation system i needed some logging mechanism for bug finding. And after implementing this interface at the plc and i kept it for data logging. Meanwhile the usual data logging is realized within the control system (node red) but for redundancy purpose the mechanism is still alive. The main script provides a IP listener for every configuret plc connection. Messages from the remote clients will be parsed and stored in a db. Wetter station For the weather station I decided for the P03/3-Modbus from Elsner. With it I can get the weather data: Brightness (east, south and west sun), wind speed, temperature and precipitation. With the Modbus variant I want to keep the possibility open to connect several participants (in special room sensors) to the control system via the bus system. The heating system My heating consists of the 20qm solar collectors and the \"romantic\" stove in the living room as well as an ETA SH20 twin. During the installation I saw that a maintenance interface is attached to the display. On inquiry with the manufacturer I got the RS232 protocol and thus the possibility by a CM1241 to access it. Here the protocoll: Byte startsign: alwas \u2019{\u2019 == hex 0x7B Byte Servicekennung Byte Servicekennung Byte Anzahl der Nutzdatenbytes Byte Pr\u00fcfsumme: alle Nutzdatenbytes addiert, modulo 256 ab 6. Byte Nutzdaten last Byte stoppsign alwas \u2019}\u2019 == hex 0x7D settings of serial interface: 19200 Baud, 1 Startbit, 8 Datenbits, 1 Stoppbit, NoParity, NoHandshake Herewith I inform the heating control that it should send out the actual values cyclically: #SEND_PTP_start(REQ := #cmd.eta_start, PORT := #CP_Adress, BUFFER := #frame_start); #cmd.eta_start := FALSE; #SEND_PTP_cmd(REQ:=#cmd.eta_cmd, PORT :=#CP_Adress, BUFFER:=#frame_cmd);","title":"field level"},{"location":"field_level/#field-level","text":"","title":"Field level"},{"location":"field_level/#iot-multisensor","text":"TODO esp 8266 description requirements upload stl file","title":"IoT multisensor"},{"location":"field_level/#data-logger","text":"During the early implementing phase of the home automation system i needed some logging mechanism for bug finding. And after implementing this interface at the plc and i kept it for data logging. Meanwhile the usual data logging is realized within the control system (node red) but for redundancy purpose the mechanism is still alive. The main script provides a IP listener for every configuret plc connection. Messages from the remote clients will be parsed and stored in a db.","title":"Data logger"},{"location":"field_level/#wetter-station","text":"For the weather station I decided for the P03/3-Modbus from Elsner. With it I can get the weather data: Brightness (east, south and west sun), wind speed, temperature and precipitation. With the Modbus variant I want to keep the possibility open to connect several participants (in special room sensors) to the control system via the bus system.","title":"Wetter station"},{"location":"field_level/#the-heating-system","text":"My heating consists of the 20qm solar collectors and the \"romantic\" stove in the living room as well as an ETA SH20 twin. During the installation I saw that a maintenance interface is attached to the display. On inquiry with the manufacturer I got the RS232 protocol and thus the possibility by a CM1241 to access it. Here the protocoll: Byte startsign: alwas \u2019{\u2019 == hex 0x7B Byte Servicekennung Byte Servicekennung Byte Anzahl der Nutzdatenbytes Byte Pr\u00fcfsumme: alle Nutzdatenbytes addiert, modulo 256 ab 6. Byte Nutzdaten last Byte stoppsign alwas \u2019}\u2019 == hex 0x7D settings of serial interface: 19200 Baud, 1 Startbit, 8 Datenbits, 1 Stoppbit, NoParity, NoHandshake Herewith I inform the heating control that it should send out the actual values cyclically: #SEND_PTP_start(REQ := #cmd.eta_start, PORT := #CP_Adress, BUFFER := #frame_start); #cmd.eta_start := FALSE; #SEND_PTP_cmd(REQ:=#cmd.eta_cmd, PORT :=#CP_Adress, BUFFER:=#frame_cmd);","title":"The heating system"},{"location":"hints/","text":"some useful hints usage MkDocs mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. gh-deploy Deploy your documentation to GitHub Pages Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"hints"},{"location":"hints/#some-useful-hints","text":"","title":"some useful hints"},{"location":"hints/#usage-mkdocs","text":"mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. gh-deploy Deploy your documentation to GitHub Pages","title":"usage MkDocs"},{"location":"hints/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"processing_level/","text":"Processing level The core components of my home automation solution consist of Siemens Simatic 1200 series CPUs. These are actually used in industrial environments (so they meet my requirements regarding robustness) and were priced within my budget. The picture shows a sub-distributor during the construction phase. Right beside the multimeter you can see a 1214C CPU with 3x DI/DO expansion modules. The CPUs are programmed with SCL (Structured Control Language). The syntax is similar to Pascal. In the following I describe the user program in excerpts. Simatic PLC programm aktor interface My focus was on a generic solution in order to be able to extend the control program easily or to port it to another environment without major adaptations. For each actuator type (light, jalouse, socket, heating) there is a general function module that is instantiated for each device. Here is an example of the light building block. This is called several times in a superimposed \"control\" block. ash became light IF #turn_on THEN #switch_signal := true; END_IF; #Tturn_off(IN:=#turn_off, PT:=t#5s, Q= #tmp_turn_off_hold); IF #param. auto-off_lux_enable THEN # Tauto-off-lux (IN := sense_lux_stairs_og #param. auto-off_lux , PT := t#10s, Q = #tmp_turn_off_lux ); END_IF; Since the interior of the house took place over the winter, I realized the light building block first. The module has one input to change the output signal and one input to switch it on and one input to switch it off. The output switches directly the coupling relay which controls the physical light. In the \"inner life\" of the module there is a delay to prevent the rear switching on/off (I implemented this function because of a stress test of my kids). In addition there is a timer which switches off the light after a configured time and the possibility to also switch off the light if a brightness value is exceeded. and getting dark again The blind building block was a little trickier. Because I can't evaluate the signal of the physical end stop in the control I measured the time of the up and down movement. The target position and the target angle of the slats (each in 0 - 100%) are transferred to an extra \"blind motor\" module. In this module, the time of the actual position and the actual angle is continuously normalized and the target values are approached in a state machine. In addition, I have locked a simultaneous up and down signal at the outputs at different positions. // normierung der position/zeit zwischen 0 - 100 #cur_data.position := REAL_TO_INT(NORM_X(MIN := 0, VALUE := #cur_data.position_in_time, MAX := #DRIVING_TIME_POSITION) * #DIGIT_SCALA); #cur_data.angle := REAL_TO_INT(NORM_X(MIN := 0, VALUE := #cur_data.angle_in_time, MAX := #DRIVING_TIME_ANGLE) * #DIGIT_SCALA); END_IF; The blind module has the following features: When the up/down button is pressed briefly, the blind moves to the respective end position (i.e. completely up or completely down). If the blind is moving and the up/down button is pressed again, the motor stops. If a button is pressed for a longer period of time ( 300ms have become established), the motor moves until the button is released again. Automatic startup when a parameterized wind speed is exceeded (measured by the weather station) Time-controlled approach of a position and an angle (I have planned 10 events so far but needed a maximum of 4) still on the TO-DO list: event-based approaching of an angle due to solar radiation and room temperature heating module The heating module is kept simpler again. Due to the relatively sluggish wall heating, I have not yet implemented an exact regulation of the heating circuits. In order to avoid a constant toggling the servomotors switch off only with 0,5 degrees over target. In addition, an interval can be parameterized if the temperature falls below the target value and the time of day during which the module is to be active. For IBS purposes (and e.g. vacation time), the PC-Tool can also be used to switch to manual mode (defined on or off). TO-DO Current I have not yet realized the socket module. Currently I only switch the sockets in the children's room. Since here however a bedside lamp is switched I also used the light component for it. communication For external communication each CPU contains a net_interface block. Here a UDP/IP server is realized in a state machine which can be addressed e.g. via the PC-Tool. Each instance of an actuator block is given a unique ID. This ID can also be found in the PC tool.","title":"process"},{"location":"processing_level/#processing-level","text":"The core components of my home automation solution consist of Siemens Simatic 1200 series CPUs. These are actually used in industrial environments (so they meet my requirements regarding robustness) and were priced within my budget. The picture shows a sub-distributor during the construction phase. Right beside the multimeter you can see a 1214C CPU with 3x DI/DO expansion modules. The CPUs are programmed with SCL (Structured Control Language). The syntax is similar to Pascal. In the following I describe the user program in excerpts.","title":"Processing level"},{"location":"processing_level/#simatic-plc-programm","text":"","title":"Simatic PLC programm"},{"location":"processing_level/#aktor-interface","text":"My focus was on a generic solution in order to be able to extend the control program easily or to port it to another environment without major adaptations. For each actuator type (light, jalouse, socket, heating) there is a general function module that is instantiated for each device. Here is an example of the light building block. This is called several times in a superimposed \"control\" block. ash became light IF #turn_on THEN #switch_signal := true; END_IF; #Tturn_off(IN:=#turn_off, PT:=t#5s, Q= #tmp_turn_off_hold); IF #param. auto-off_lux_enable THEN # Tauto-off-lux (IN := sense_lux_stairs_og #param. auto-off_lux , PT := t#10s, Q = #tmp_turn_off_lux ); END_IF; Since the interior of the house took place over the winter, I realized the light building block first. The module has one input to change the output signal and one input to switch it on and one input to switch it off. The output switches directly the coupling relay which controls the physical light. In the \"inner life\" of the module there is a delay to prevent the rear switching on/off (I implemented this function because of a stress test of my kids). In addition there is a timer which switches off the light after a configured time and the possibility to also switch off the light if a brightness value is exceeded. and getting dark again The blind building block was a little trickier. Because I can't evaluate the signal of the physical end stop in the control I measured the time of the up and down movement. The target position and the target angle of the slats (each in 0 - 100%) are transferred to an extra \"blind motor\" module. In this module, the time of the actual position and the actual angle is continuously normalized and the target values are approached in a state machine. In addition, I have locked a simultaneous up and down signal at the outputs at different positions. // normierung der position/zeit zwischen 0 - 100 #cur_data.position := REAL_TO_INT(NORM_X(MIN := 0, VALUE := #cur_data.position_in_time, MAX := #DRIVING_TIME_POSITION) * #DIGIT_SCALA); #cur_data.angle := REAL_TO_INT(NORM_X(MIN := 0, VALUE := #cur_data.angle_in_time, MAX := #DRIVING_TIME_ANGLE) * #DIGIT_SCALA); END_IF; The blind module has the following features: When the up/down button is pressed briefly, the blind moves to the respective end position (i.e. completely up or completely down). If the blind is moving and the up/down button is pressed again, the motor stops. If a button is pressed for a longer period of time ( 300ms have become established), the motor moves until the button is released again. Automatic startup when a parameterized wind speed is exceeded (measured by the weather station) Time-controlled approach of a position and an angle (I have planned 10 events so far but needed a maximum of 4) still on the TO-DO list: event-based approaching of an angle due to solar radiation and room temperature heating module The heating module is kept simpler again. Due to the relatively sluggish wall heating, I have not yet implemented an exact regulation of the heating circuits. In order to avoid a constant toggling the servomotors switch off only with 0,5 degrees over target. In addition, an interval can be parameterized if the temperature falls below the target value and the time of day during which the module is to be active. For IBS purposes (and e.g. vacation time), the PC-Tool can also be used to switch to manual mode (defined on or off). TO-DO Current I have not yet realized the socket module. Currently I only switch the sockets in the children's room. Since here however a bedside lamp is switched I also used the light component for it.","title":"aktor interface"},{"location":"processing_level/#communication","text":"For external communication each CPU contains a net_interface block. Here a UDP/IP server is realized in a state machine which can be addressed e.g. via the PC-Tool. Each instance of an actuator block is given a unique ID. This ID can also be found in the PC tool.","title":"communication"},{"location":"references/","text":"Links / Downlads nr component link 0 this repo github.com/alexkratzer/autohomestack 1 outdated dotNet frontend github.com/alexkratzer/ahGUI","title":"References"},{"location":"references/#links-downlads","text":"nr component link 0 this repo github.com/alexkratzer/autohomestack 1 outdated dotNet frontend github.com/alexkratzer/ahGUI","title":"Links / Downlads"},{"location":"images/readme_plantuml/","text":"plantuml code for readme until I get the plant-uml plugin working here is the code to the pictures Components of the auto home stack @startuml skinparam component { FontColor black AttributeFontColor black FontSize 17 AttributeFontSize 15 AttributeFontname Droid Sans Mono BackgroundColor #6A9EFF BorderColor black ArrowColor #222266 } title auto home stack skinparam componentStyle uml2 node user interface { frame deprecated { [dotnet pc tool] #Gray } [dotnet pc tool] -- udp_plc [web client] .. http } cloud { interface www [AWS] -- www [netatmo] - www } node ahs { interface data_logger as data_logger interface mqtt [data logger server] as dls [rpi_nodered] as nr dls -up- [dashboard] [dashboard] - http dls -- data_logger www - nr http -- nr nr -right- [plc_xx] nr - dls nr -down- mqtt udp_plc - [plc_xx] data_logger - [plc_xx] [plc_xy] -up- [plc_xx] [esp] .up. mqtt [sensor] -up- [plc_xx] [aktor] -up- [plc_xx] } @enduml legend @startuml node Legend { package device { [item 1] as TMS #Tomato } folder tst { [item 2] as CM #Lime } } @enduml node red @startuml [*] -- NodeRed udp - NodeRed NodeRed - udp udp : plc interface mqtt -- NodeRed NodeRed -- mqtt mqtt : field level devices\\nesp 8266,\\nwatchdog services, ... iot -- NodeRed NodeRed -- iot iot : other interfaces \\nlike rest apis, AWS S3,\\nssh to linux devices,\\n... NodeRed -- db db : MySQL and \\nInfluxDB NodeRed : store all prozess \\nand event data\\nprozess data with rule engine\\n @enduml","title":"plantuml code"},{"location":"images/readme_plantuml/#plantuml-code-for-readme","text":"until I get the plant-uml plugin working here is the code to the pictures","title":"plantuml code for readme"},{"location":"images/readme_plantuml/#components-of-the-auto-home-stack","text":"@startuml skinparam component { FontColor black AttributeFontColor black FontSize 17 AttributeFontSize 15 AttributeFontname Droid Sans Mono BackgroundColor #6A9EFF BorderColor black ArrowColor #222266 } title auto home stack skinparam componentStyle uml2 node user interface { frame deprecated { [dotnet pc tool] #Gray } [dotnet pc tool] -- udp_plc [web client] .. http } cloud { interface www [AWS] -- www [netatmo] - www } node ahs { interface data_logger as data_logger interface mqtt [data logger server] as dls [rpi_nodered] as nr dls -up- [dashboard] [dashboard] - http dls -- data_logger www - nr http -- nr nr -right- [plc_xx] nr - dls nr -down- mqtt udp_plc - [plc_xx] data_logger - [plc_xx] [plc_xy] -up- [plc_xx] [esp] .up. mqtt [sensor] -up- [plc_xx] [aktor] -up- [plc_xx] } @enduml","title":"Components of the auto home stack"},{"location":"images/readme_plantuml/#legend","text":"@startuml node Legend { package device { [item 1] as TMS #Tomato } folder tst { [item 2] as CM #Lime } } @enduml","title":"legend"},{"location":"images/readme_plantuml/#node-red","text":"@startuml [*] -- NodeRed udp - NodeRed NodeRed - udp udp : plc interface mqtt -- NodeRed NodeRed -- mqtt mqtt : field level devices\\nesp 8266,\\nwatchdog services, ... iot -- NodeRed NodeRed -- iot iot : other interfaces \\nlike rest apis, AWS S3,\\nssh to linux devices,\\n... NodeRed -- db db : MySQL and \\nInfluxDB NodeRed : store all prozess \\nand event data\\nprozess data with rule engine\\n @enduml","title":"node red"}]}